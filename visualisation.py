"""This module is used for the visualisation of the bounding boxes."""

import shlex
import os
import csv
from PIL import Image, ImageDraw

imgs_path = '/Users/dl1122/Downloads/Archive/data/images'
bbspath = '/Users/dl1122/Downloads/Archive/test\ export\ folder/detections'
bbspath = shlex.split(bbspath)[0]


loc_path = '/Users/dl1122/Downloads/Archive/data/locations'

def atomBound(imgpath, bbpath, csv_exist=True):
  """
        This function is used in boundBox() and comparedBox() (see below).
        It helps plot bounding boxes on the images. 

        Parameters
        ----------
        imgpath: str, path to the original image.
        bbpath: str, str, path to csv file generated by the model containing information about detected bounded boxes.
        csv_exist: Boolean, True if bbpath exists (False if the model does not detect any craters).

        Returns
        -------
        rawimg: obj
        postimg: obj

        """
  
  rawimg = Image.open(imgpath)
  rawimg = rawimg.convert("RGB")
  postimg = ImageDraw.ImageDraw(rawimg)
  w,h = rawimg.size
  
  if csv_exist == True:
    with open(bbpath) as bboxloc:
      reader = csv.reader(bboxloc)
      for i, rows in enumerate(reader):
          postimg.rectangle(((float(rows[0])*w - float(rows[2])*w/2, float(rows[1])*h - 
                                        float(rows[3])*h/2), (float(rows[0])*w + float(rows[2])*w/2, float(rows[1])*h + float(rows[3])*h/2)), fill=None, outline='red', width=1)
  return rawimg, postimg


def boundBox(imgpath, bbpath, outpath, csv_exist):
  """
        Plots bounding box of detected craters on the images.

        Parameters
        ----------
        imgpath: str, path to the original image.
        bbpath: str, str, path to csv file generated by the model containing information about detected bounded boxes.
        outpath: str, path to png output images.
        csv_exist: Boolean, True if bbpath exists (False if the model does not detect any craters).

        Returns
        -------
        None

        """

  rawimg, postimg = atomBound(imgpath, bbpath, csv_exist)
  rawimg.save(outpath)


def comparedBox(imgpath, bbpath, tbpath, outpath, csv_exist):
  """
        Plots bounding box of ground truth craters on the images.

        Parameters
        ----------
        imgpath: str, path to the original image.
        bbpath: str, str, path to csv file generated by the model containing information about detected bounded boxes.
        outpath: str, path to png output images.
        csv_exist: Boolean, True if bbpath exists (False if the model does not detect any craters).

        Returns
        -------
        None

        """
        
  rawimg, postimg = atomBound(imgpath, bbpath, csv_exist)
  w,h = rawimg.size 
  
  print('tbpath================================================================')
  print(tbpath)
  with open(tbpath) as tboxloc:
    reader = csv.reader(tboxloc)
    for i, rows in enumerate(reader):
        postimg.rectangle(((float(rows[0])*w - float(rows[2])*w/2, float(rows[1])*h - 
                                       float(rows[3])*h/2), (float(rows[0])*w + float(rows[2])*w/2, float(rows[1])*h + float(rows[3])*h/2)), fill=None, outline='blue', width=1)
  rawimg.save(outpath)


def to_coords(imgpath, lat, lon, bbpath, R, image_scale):
    '''
    Converts coordinates from the format [0,1] to latitude and longitude for a given 
    location at the centre of the image.
    
    Parameters
    -------------
    x: x coordinate for crater location in [0,1]
    y: y coordinate for crater location in [0,1]
    w: width of the rectangle fitting around the crater in [0,1]
    h: height of the rectangle fitting around the crater in [0,1]
    lat_centre: latitude of the location at the centre of the image
    lon_centre: longitude of the location at the centre of the image
    lat_range: height of the image in degrees latitude
    lon_range: width of the image in degrees longitude
    
    Returns
    --------------
    Coordinates x, y of the crater location in longitude and latitude 
    Width w and height h of the rectangle fitting around the crater in degrees latitude and longitude

    This function is called in ...
    
    '''

    crtP = []
    rawimg = Image.open(imgpath)
    imgW,imgH = rawimg.size

    with open(bbpath) as bboxloc:
      reader = csv.reader(bboxloc)
      for i, rows in enumerate(reader):
        crtP.append(rows[:4])
        crtP[i] += ([float(rows[0])*imgW*image_scale/(1000 * R) + lon, lat - float(rows[1])*imgH*image_scale/(1000 * R) , (max(float(rows[2])*imgW, float(rows[3])*imgH)*(image_scale / 1000))])

    with open(bbpath, 'w', newline='') as file:
      writer = csv.writer(file)
      writer.writerows(crtP)


def add_loc_all_detected_csv(bbspath,imgs_path,loc_path,image_scale = 100, planet = 'mars'):
  
  if planet == 'mars':
    R = 3389.5
  else:
    R = 1737.4
  
  # get a list of files in the directory
  detected_files = os.listdir(bbspath)
  # iterate through each file
  for each_csv in detected_files:
      # get the full path of the file
      file_path = os.path.join(bbspath, each_csv)
      # check if the path is a file
      if os.path.isfile(file_path) and each_csv.endswith(".csv"):
        image_title = os.path.splitext(each_csv)[0]
        
        #location file path
        loc_file_path = os.path.join(loc_path, image_title +'.csv')

        #image file path
        for file in os.listdir(imgs_path):
          if file.startswith(image_title) and (file.endswith(".png") or file.endswith(".jpg") or file.endswith(".tif")):
              img_file_path = os.path.join(imgs_path, file)                             

        with open(loc_file_path, 'r') as file:
          reader = csv.reader(file)
          for row in reader:
              latitude = float(row[0])
              longitude = float(row[1])
        to_coords(img_file_path, latitude, longitude, file_path,100,R)
        
              
        
        




